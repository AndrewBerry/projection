<canvas id="canvas" width="800" height="600"></canvas>

<style>
  #canvas {
    position: absolute;
    top: 50%;
    left: 50%;

    transform: translate(-50%, -50%);
    background-color: #fafafa;
  }
</style>

<script>
  class PolygonFace {
    constructor(vertices, color) {
      this.vertices = vertices;
      this.color = color;

      // find mid point
      const totals = vertices.reduce((sums, vertex) => {
        return sums.map((sum, sumIndex) => sum += vertex[sumIndex]);
      }, [0, 0, 0]);
      this.middle = totals.map(val => val / vertices.length);

      // find face normal
      this.normal = [0, 0, 0];
      vertices.forEach((vertex, vertexIndex) => {
        const nextVertex = vertices[(vertexIndex + 1) % vertices.length];

        this.normal[0] += (vertex[1] - nextVertex[1]) * (vertex[2] + nextVertex[2]);
        this.normal[1] += (vertex[2] - nextVertex[2]) * (vertex[0] + nextVertex[0]);
        this.normal[2] += (vertex[0] - nextVertex[0]) * (vertex[1] + nextVertex[1]);
      });
    }
  }

  const CANVAS_WIDTH = 800
  const CANVAS_HEIGHT = 600;

  // cube
  const cubeFaces = [
    new PolygonFace( // back left
      [
        [0, 0, 0],
        [0, 0, 200],
        [0, 100, 200],
        [0, 100, 0],
      ],
      'green',
    ),
    new PolygonFace( // back right
      [
        [100, 0, 0],
        [100, 0, 50],
        [0, 0, 200],
        [0, 0, 0],
      ],
      'orange',
    ),
    new PolygonFace( // front right
      [
        [100, 100, 50],
        [100, 0, 50],
        [100, 0, 0],
        [100, 100, 0],
      ],
      'yellow',
    ),
    new PolygonFace( // front left
      [
        [0, 100, 0],
        [0, 100, 200],
        [100, 100, 50],
        [100, 100, 0],
      ],
      'blue',
    ),
    new PolygonFace( // top
      [
        [100, 0, 50],
        [100, 100, 50],
        [0, 100, 200],
        [0, 0, 200],
      ],
      'pink',
    ),
  ];

  function degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  }

  function project3dTo2d(vertex, cameraPosition, cameraAngle) {
    let [x, y, z] = vertex;
    const [cx, cy, cz] = cameraPosition;
    const cameraRadians = degreesToRadians(cameraAngle);

    // adjust by camera position
    [x, y, z] = [x - cx, y - cy, z - cz];

    // rotate
    rx = x * Math.cos(cameraRadians) - y * Math.sin(cameraRadians);
    ry = x * Math.sin(cameraRadians) + y * Math.cos(cameraRadians);

    // project x
    const resultX =
      rx * Math.cos(degreesToRadians(30)) +
      ry * Math.cos(degreesToRadians(150)) +
      z * Math.cos(degreesToRadians(-90)) +
      CANVAS_WIDTH / 2;

    // project y
    const resultY =
      rx * Math.sin(degreesToRadians(30)) +
      ry * Math.sin(degreesToRadians(150)) +
      z * Math.sin(degreesToRadians(-90)) +
      CANVAS_HEIGHT / 2;

    return [resultX, resultY];
  }

  function fillPolygon(face, cameraPosition, cameraAngle, context) {
    // draw edges
    context.beginPath();
    context.moveTo(...project3dTo2d(face.vertices[0], cameraPosition, cameraAngle));

    face.vertices.forEach(vertex => {
      context.lineTo(...project3dTo2d(vertex, cameraPosition, cameraAngle));
    });

    context.lineTo(...project3dTo2d(face.vertices[0], cameraPosition, cameraAngle));

    context.closePath();
    context.strokeStyle = face.color;
    context.stroke();

    // display normal
    context.beginPath();

    context.moveTo(...project3dTo2d(face.middle, cameraPosition, cameraAngle));

    const normalEndPoint = face.middle.map((val, index) => {
      return val + face.normal[index];
    });

    context.lineTo(...project3dTo2d(normalEndPoint, cameraPosition, cameraAngle));

    context.closePath();
    context.strokeStyle = face.color;
    context.stroke();
  }

  // camera
  const cameraPosition = [50, 50, 0];
  let cameraAngle = 0;

  // drawing context
  const context = document.getElementById('canvas').getContext('2d');
  context.strokeStyle = '#000000';
  context.lineWidth = '1';

  setInterval(() => {
    cameraAngle += 1;

    context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    cubeFaces.forEach(face => {
      fillPolygon(face, cameraPosition, cameraAngle, context);
    });
  }, 20);
</script>
